// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use attest_data::AttestDataError as OxAttestDataError;
use dice_verifier::{
    Attest as OxAttest, AttestError as OxAttestError,
    Attestation as OxAttestation, Log, Nonce,
};
use hubpack::SerializedSize;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use uuid::Uuid;
use x509_cert::der::Encode;

use crate::{
    MeasurementLog, QualifyingData, RotType, VmInstanceAttestation,
    VmInstanceRot,
};

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Measurement {
    pub algorithm: String,
    pub digest: String,
}

/// A representation of the measurement log produced by the VM instance RoT.
/// This is the log of measurements that propolis mixes into the data provided
/// to the attestation produced by the `RotType::OxidePlatform`.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct VmInstanceConf {
    pub uuid: Uuid,
    #[serde(rename = "image-digest")]
    pub image_digest: Option<Measurement>,
}

/// Errors returned when trying to sign an attestation
#[derive(Debug, thiserror::Error)]
pub enum VmInstanceRotMockError {
    #[error("error encoding cert as DER")]
    DerEncodeError(#[from] x509_cert::der::Error),
    #[error("error deserializing data")]
    Serialize,
    #[error("error from Oxide attestation interface")]
    OxideAttestError(#[from] OxAttestError),
    #[error("error from Oxide attestation data")]
    OxideAttestDataError(#[from] OxAttestDataError),
    #[error("Rot has no cert chain")]
    NoCertChain,
    #[error("error converting instance log")]
    VmInstanceMocData(#[from] serde_json::Error),
}

/// This type mocks the `propolis` process that backs a VM.
pub struct VmInstanceRotMock {
    oxattest_mock: Box<dyn OxAttest>,
    log: VmInstanceConf,
}

impl VmInstanceRotMock {
    pub fn new(oxattest_mock: Box<dyn OxAttest>, log: VmInstanceConf) -> Self {
        Self { oxattest_mock, log }
    }
}

impl VmInstanceRot for VmInstanceRotMock {
    type Error = VmInstanceRotMockError;

    /// `propolis` receives qualifying data from the caller. It then combines
    /// this data w/ attributes describing the VM (rootfs, instance UUID etc)
    /// and attestations from other RoTs on the platform. The format of each
    /// attestation is dependent on the associated `RotType`.
    fn attest(
        &self,
        qualifying_data: &QualifyingData,
    ) -> Result<VmInstanceAttestation, Self::Error> {
        let instance_cfg = serde_json::to_string(&self.log)?;

        // Roll the VM config data (UUID & rootfs digest) into a digest with
        // the qualifying data provided by the VM instance.
        let mut msg = Sha256::new();
        // TODO: hash the UUID & rootfs digest directly instead of the CFG JSON
        // structure
        msg.update(instance_cfg.as_bytes());
        msg.update(qualifying_data);

        // smuggle the updated qualifying data through the `Nonce`
        // type down to the Oxide Platform RoT
        let nonce = Nonce::N32(attest_data::Array(msg.finalize().into()));
        let attest = self.oxattest_mock.attest(&nonce)?;

        // serialize the attestation back to hubpack
        // TODO: this should be a JSON encoding
        let mut attestation = vec![0u8; OxAttestation::MAX_SIZE];
        let len = hubpack::serialize(&mut attestation, &attest)
            .map_err(|_| Self::Error::Serialize)?;
        attestation.truncate(len);

        // collect logs
        let oxide_log = self.oxattest_mock.get_measurement_log()?;

        let mut data = vec![0u8; Log::MAX_SIZE];
        let len = hubpack::serialize(&mut data, &oxide_log)
            .map_err(|_| Self::Error::Serialize)?;
        data.truncate(len);

        let mut measurement_logs = Vec::new();
        let rot = RotType::OxidePlatform;
        measurement_logs.push(MeasurementLog { rot, data });

        measurement_logs.push(MeasurementLog {
            rot: RotType::OxideInstance,
            data: serde_json::to_string(&self.log)?.as_bytes().to_vec(),
        });

        // get cert chain
        let ox_cert_chain = self.oxattest_mock.get_certificates()?;

        let mut cert_chain = Vec::new();
        for cert in ox_cert_chain {
            cert_chain.push(cert.to_der()?);
        }

        Ok(VmInstanceAttestation {
            attestation,
            cert_chain,
            measurement_logs,
        })
    }
}

#[cfg(test)]
mod test {
    use crate::{mock::*, *};
    use dice_verifier::{AttestMock as OxAttestMock, Nonce};
    use std::fs;
    use x509_cert::{Certificate, der::Decode};

    /// This module holds `const &str`s with paths to test data generated by
    /// build.rs
    mod config {
        include!(concat!(env!("OUT_DIR"), "/config.rs"));
    }

    /// Pull in test data generated by build.rs & create mock RoT-Rs
    fn setup() -> VmInstanceRotMock {
        let oxattest = Box::new(
            OxAttestMock::load(
                config::SIGNER_PKIPATH,
                config::LOG,
                config::ATTESTATION_SIGNER,
            )
            .expect("failed to create OxAttestMock from inputs"),
        );

        let instance_cfg = fs::read_to_string(config::VM_INSTANCE_CFG)
            .expect("read ATTEST_INSTANCE_LOG to string");

        let instance_cfg: VmInstanceConf = serde_json::from_str(&instance_cfg)
            .expect("parse JSON from mock cfg for instance RoT");

        VmInstanceRotMock::new(oxattest, instance_cfg)
    }

    fn mock_qualifying_data() -> QualifyingData {
        // this digest will collect data passed from the VM down to the
        // VmInstanceRoT
        let mut digest = Sha256::new();

        // roll in a nonce
        // NOTE: in practice this will come from an external challenger
        let nonce = QualifyingData::from_platform_rng()
            .expect("QualifyingData from platform RNG");
        digest.update(&nonce);

        // roll in some data from the client / VM
        // NOTE: in our initial use-case this would be the public part of a
        // cryptographic key (probably encoded as SPKI) of a cryptographic key,
        // or maybe a CSR
        let user_data = vec![b'A', 65];
        digest.update(&user_data);

        // wrap the digest in the type expected by the VmInstanceRot interface
        QualifyingData::from(Into::<[u8; 32]>::into(digest.finalize()))
    }

    #[test]
    fn attest() {
        let attest = setup();
        let qualifying_data = mock_qualifying_data();

        let _ = attest
            .attest(&qualifying_data)
            .expect("VmInstanceRotMock attest");
    }

    #[test]
    fn verify_cert_chain() {
        use std::fs;

        let attest = setup();
        let qualifying_data = mock_qualifying_data();

        let plat_attest = attest
            .attest(&qualifying_data)
            .expect("VmInstanceRotMock attest");

        let root_cert = fs::read(config::PKI_ROOT).unwrap_or_else(|e| {
            panic!(
                "Read root cert for test PKI from file: {}, {e:?}",
                config::PKI_ROOT
            )
        });
        let root_cert = Certificate::load_pem_chain(&root_cert)
            .expect("Parse test root certificate");

        let mut cert_chain_pem = Vec::new();
        for cert in plat_attest.cert_chain {
            cert_chain_pem.push(
                Certificate::from_der(&cert).expect("Certificate from DER"),
            );
        }
        let verified_root = dice_verifier::verify_cert_chain(
            &cert_chain_pem,
            Some(root_cert.as_ref()),
        )
        .expect("verify cert chain");
        assert_eq!(&root_cert[0], verified_root);
    }

    #[test]
    fn verify_attestation() {
        let attest = setup();
        // qualifying data from VM to VmInstanceRot
        let vm_qualifying_data = mock_qualifying_data();

        let plat_attest = attest
            .attest(&vm_qualifying_data)
            .expect("VmInstanceRotMock get_cert_chain");

        // Reconstruct the 32 bytes passed from `VmInstanceAttestMock` down to
        // the RotType::OxidePlatform:
        let mut vm_rot_qualifying_data = Sha256::new();
        // reconstruct qualifying_data from VmInstanceRot
        for log in &plat_attest.measurement_logs {
            match log.rot {
                RotType::OxideInstance => {
                    vm_rot_qualifying_data.update(&log.data)
                }
                _ => continue,
            }
        }
        vm_rot_qualifying_data.update(&vm_qualifying_data);
        let vm_rot_qualifying_data = QualifyingData::from(
            Into::<[u8; 32]>::into(vm_rot_qualifying_data.finalize()),
        );

        // smuggle the qualifying data from the VmInstanceRot down to the
        // oxide platform RoT through the `attest_data::Nonce`
        let data_digest =
            Nonce::N32(attest_data::Array(vm_rot_qualifying_data.into_inner()));

        // get the log from the Oxide platform RoT
        let oxlog = plat_attest.measurement_logs.iter().find_map(|log| {
            if log.rot == RotType::OxidePlatform {
                Some(log)
            } else {
                None
            }
        });

        // put log in the form expected by the `verify_attestation` function
        let (log, _): (Log, _) = if let Some(oxlog) = oxlog {
            hubpack::deserialize(&oxlog.data)
                .expect("deserialize hubpacked log")
        } else {
            panic!("No measurement log for RotType::OxidePlatform");
        };

        // signer cert is the leaf
        let cert = Certificate::from_der(&plat_attest.cert_chain[0])
            .expect("Certificate from DER");

        let (attestation, _): (OxAttestation, _) =
            hubpack::deserialize(&plat_attest.attestation)
                .expect("deserialize attestation");

        let result = dice_verifier::verify_attestation(
            &cert,
            &attestation,
            &log,
            &data_digest,
        );
        assert!(result.is_ok());
    }

    #[test]
    fn appraise_log() {
        use dice_verifier::{MeasurementSet, ReferenceMeasurements};
        use rats_corim::Corim;

        let attest = setup();
        let qualifying_data = mock_qualifying_data();

        let corim = Corim::from_file(config::CORIM).expect("Corim from file");
        let rims =
            ReferenceMeasurements::try_from(std::slice::from_ref(&corim))
                .expect("Reference integrity measurements from file");

        let plat_attest = attest
            .attest(&qualifying_data)
            .expect("VmInstanceRotMock get_cert_chain");

        // construct a `VmInstanceConf` from test data
        // this is our reference for appraising the log produced by the
        // `RotType::OxideInstance`
        let instance_rim = fs::read_to_string(config::VM_INSTANCE_CFG)
            .expect("read ATTEST_INSTANCE_LOG to string");
        let instance_rim: VmInstanceConf = serde_json::from_str(&instance_rim)
            .expect("parse JSON from rim for instance RoT log");

        for log in &plat_attest.measurement_logs {
            match log.rot {
                RotType::OxidePlatform => {
                    // use dice-verifier crate to use the RIMs to appraise the
                    // log from the OxidePlatform RoT
                    let (log, _): (Log, _) = hubpack::deserialize(&log.data)
                        .expect("deserialize hubpacked log");
                    let mut cert_chain_pem = Vec::new();
                    for cert in &plat_attest.cert_chain {
                        cert_chain_pem.push(
                            Certificate::from_der(&cert)
                                .expect("Certificate from DER"),
                        );
                    }

                    let measurements =
                        MeasurementSet::from_artifacts(&cert_chain_pem, &log)
                            .expect("MeasurementSet from PkiPath and Log");

                    let result = dice_verifier::verify_measurements(
                        &measurements,
                        &rims,
                    );
                    assert!(result.is_ok());
                }
                RotType::OxideInstance => {
                    // compare log / config description from the OxideInstance
                    // RoT to the reference from the config reference
                    let instance_cfg = std::str::from_utf8(&log.data)
                        .expect("utf8 from log data");
                    let instance_cfg: VmInstanceConf =
                        serde_json::from_str(instance_cfg)
                            .expect("parse JSON from log data");

                    assert_eq!(instance_rim, instance_cfg);
                }
            }
        }
    }
}
