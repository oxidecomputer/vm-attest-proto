// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

use attest_data::AttestDataError as OxAttestDataError;
use dice_verifier::{
    Attest as OxAttest, AttestError as OxAttestError,
    Attestation as OxAttestation, Log,
};
use hubpack::SerializedSize;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use uuid::Uuid;
use x509_cert::der::Encode;

use crate::{
    Attestation, CertChain, MeasurementLog, Nonce, RotType, VmInstanceAttester,
};

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct Measurement {
    pub algorithm: String,
    pub digest: String,
}

/// A representation of the measurement log produced by the VM instance RoT.
/// This is the log of measurements that propolis mixes into the data provided
/// to the attestation produced by the `RotType::OxidePlatform`.
#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub struct VmInstanceConf {
    pub uuid: Uuid,
    #[serde(rename = "image-digest")]
    pub image_digest: Measurement,
}

/// Errors returned when trying to sign an attestation
#[derive(Debug, thiserror::Error)]
pub enum VmInstanceAttestMockError {
    #[error("error encoding cert as DER")]
    DerEncodeError(#[from] x509_cert::der::Error),
    #[error("error deserializing data")]
    Serialize,
    #[error("error from Oxide attestation interface")]
    OxideAttestError(#[from] OxAttestError),
    #[error("error from Oxide attestation data")]
    OxideAttestDataError(#[from] OxAttestDataError),
    #[error("Rot has no cert chain")]
    NoCertChain,
    #[error("error converting instance log")]
    VmInstanceMocData(#[from] serde_json::Error),
}

/// This type mocks the `propolis` process that backs a VM.
pub struct VmInstanceAttestMock {
    oxattest_mock: Box<dyn OxAttest>,
    log: VmInstanceConf,
}

impl VmInstanceAttestMock {
    pub fn new(oxattest_mock: Box<dyn OxAttest>, log: VmInstanceConf) -> Self {
        Self { oxattest_mock, log }
    }
}

impl VmInstanceAttester for VmInstanceAttestMock {
    type Error = VmInstanceAttestMockError;

    /// `propolis` receives the nonce & user data from the caller.
    /// It then combines this data w/ attributes describing the VM (rootfs,
    /// instance UUID etc) and attestations from other RoTs on the platform.
    /// The format of each attestation is dependent on the associated `RotType`.
    /// NOTE: the order of the attestations returned is significant
    fn attest(
        &self,
        nonce: &Nonce,
        user_data: &[u8],
    ) -> Result<Vec<Attestation>, Self::Error> {
        let instance_cfg = serde_json::to_string(&self.log)?;

        let mut msg = Sha256::new();
        msg.update(instance_cfg.as_bytes());
        msg.update(nonce);
        msg.update(user_data);
        let msg = msg.finalize();

        let nonce = attest_data::Nonce { 0: msg.into() };
        let attest = self.oxattest_mock.attest(&nonce)?;

        let mut data = vec![0u8; OxAttestation::MAX_SIZE];
        let len = hubpack::serialize(&mut data, &attest)
            .map_err(|_| Self::Error::Serialize)?;
        data.truncate(len);

        Ok(vec![Attestation {
            rot: RotType::OxidePlatform,
            data,
        }])
    }

    /// Get all measurement logs from the various RoTs on the platform.
    fn get_measurement_logs(&self) -> Result<Vec<MeasurementLog>, Self::Error> {
        let oxide_log = self.oxattest_mock.get_measurement_log()?;

        let mut data = vec![0u8; Log::MAX_SIZE];
        let len = hubpack::serialize(&mut data, &oxide_log)
            .map_err(|_| Self::Error::Serialize)?;
        data.truncate(len);

        let mut logs = Vec::new();
        let rot = RotType::OxidePlatform;
        logs.push(MeasurementLog { rot, data });

        logs.push(MeasurementLog {
            rot: RotType::OxideInstance,
            data: serde_json::to_string(&self.log)?.as_bytes().to_vec(),
        });

        Ok(logs)
    }

    fn get_cert_chains(&self) -> Result<Vec<CertChain>, Self::Error> {
        let ox_cert_chain = self.oxattest_mock.get_certificates()?;

        let mut certs = Vec::new();
        for cert in ox_cert_chain {
            certs.push(cert.to_der()?);
        }

        let oxide_platform = CertChain {
            rot: RotType::OxidePlatform,
            certs,
        };

        Ok(vec![oxide_platform])
    }
}

#[cfg(test)]
mod test {
    use crate::{mock::*, *};
    use dice_verifier::AttestMock as OxAttestMock;
    use std::fs;
    use x509_cert::{
        Certificate,
        der::{Decode, asn1::Utf8StringRef},
    };

    /// This module holds `const &str`s with paths to test data generated by
    /// build.rs
    mod config {
        include!(concat!(env!("OUT_DIR"), "/config.rs"));
    }

    // make this more interesting
    const NONCE: [u8; 32] = [0u8; 32];
    const USER_DATA: [u8; 32] = [0u8; 32];

    /// Pull in test data generated by build.rs & create mock RoT-Rs
    fn setup() -> VmInstanceAttestMock {
        let oxattest = Box::new(
            OxAttestMock::load(
                config::SIGNER_PKIPATH,
                config::LOG,
                config::ATTESTATION_SIGNER,
            )
            .expect("failed to create OxAttestMock from inputs"),
        );

        let instance_cfg = fs::read_to_string(config::VM_INSTANCE_CFG)
            .expect("read ATTEST_INSTANCE_LOG to string");

        let instance_cfg: VmInstanceConf = serde_json::from_str(&instance_cfg)
            .expect("parse JSON from mock cfg for instance RoT");

        VmInstanceAttestMock::new(oxattest, instance_cfg)
    }

    #[test]
    fn get_measurement_logs() {
        let attest = setup();

        let logs = attest.get_measurement_logs().expect("get_measurement_logs");
        for log in logs {
            match log.rot {
                RotType::OxidePlatform => assert!(!log.data.is_empty()),
                RotType::OxideInstance => assert!(!log.data.is_empty()),
            }
        }
    }

    // utility function to get common name from cert subject
    fn get_cert_cn(cert: &Certificate) -> Option<Utf8StringRef<'_>> {
        use const_oid::db::rfc4519::COMMON_NAME;

        for elm in cert.tbs_certificate.subject.0.iter() {
            for atav in elm.0.iter() {
                if atav.oid == COMMON_NAME {
                    return Some(
                        Utf8StringRef::try_from(&atav.value).expect(
                            "Decode name attribute value to UTF8 string",
                        ),
                    );
                }
            }
        }

        None
    }

    #[test]
    fn get_cert_chain() {
        let attest = setup();

        let cert_chains = attest.get_cert_chains().expect("get_cert_chains");
        assert_eq!(cert_chains.len(), 1);
        assert!(cert_chains[0].certs.len() > 1);

        // the leaf cert CN is defined in test-data/config.kdl
        let cert = Certificate::from_der(&cert_chains[0].certs[0])
            .expect("Certificate from DER");
        let leaf_cn = get_cert_cn(&cert);
        assert_eq!(leaf_cn, Some(Utf8StringRef::new("alias").unwrap()));
    }

    #[test]
    fn attest() {
        let attest = setup();

        let nonce =
            Nonce::from_platform_rng().expect("Nonce from platform RNG");
        // TODO: should be a crypto key
        let user_data = vec![0u8, 1];

        let _ = attest
            .attest(&nonce, &user_data)
            .expect("VmInstanceAttestMock attest");
    }

    #[test]
    fn verify_cert_chain() {
        use std::fs;

        let attest = setup();
        let cert_chains = attest.get_cert_chains().expect("get cert chain");

        let root_cert = fs::read(config::PKI_ROOT).unwrap_or_else(|e| {
            panic!(
                "Read root cert for test PKI from file: {}, {e:?}",
                config::PKI_ROOT
            )
        });
        let root_cert = Certificate::load_pem_chain(&root_cert)
            .expect("Parse test root certificate");

        for cert_chain in cert_chains {
            match cert_chain.rot {
                RotType::OxidePlatform => {
                    let mut cert_chain_pem = Vec::new();
                    for cert in cert_chain.certs {
                        cert_chain_pem.push(
                            Certificate::from_der(&cert)
                                .expect("Certificate from DER"),
                        );
                    }
                    let verified_root = dice_verifier::verify_cert_chain(
                        &cert_chain_pem,
                        Some(root_cert.as_ref()),
                    )
                    .expect("verify cert chain");
                    assert_eq!(&root_cert[0], verified_root);
                }
                // this RoT doesn't have a cert chain
                RotType::OxideInstance => assert!(false),
            }
        }
    }

    #[test]
    fn verify_attestation() {
        let attest = setup();

        // Data passed from VM through API to propolis.
        // propolis, acting as the (sorta) RoT for VM mixes this into the 32
        // bytes that it passes to the oxide RoT for signing.
        // We'll need this later (along with the logs) to verify the attestation.
        let nonce = Nonce::from_array(NONCE);

        let cert_chains = attest
            .get_cert_chains()
            .expect("VmInstanceAttestMock get_cert_chain");
        assert_eq!(cert_chains.len(), 1);
        // signer cert is the leaf
        let cert = Certificate::from_der(&cert_chains[0].certs[0])
            .expect("Certificate from DER");

        let attestations = attest
            .attest(&nonce, &USER_DATA)
            .expect("VmInstanceAttestMock attest");

        assert_eq!(attestations.len(), 1);
        let attestation = &attestations[0];

        assert_eq!(attestation.rot, RotType::OxidePlatform);

        let (attestation, _): (OxAttestation, _) =
            hubpack::deserialize(&attestation.data)
                .expect("deserialize attestation");

        let logs = attest.get_measurement_logs().expect("get_measurement_logs");

        // Reconstruct the 32 bytes passed from `VmInstanceAttestMock` down to
        // the RotType::OxidePlatform:
        //
        // The challenger passes OxideInstance RoT 32 byte nonce and a &[u8]
        // that we call `data`. It then combines them as:
        // `sha256(instance_log | nonce | data)`
        let mut data_digest = Sha256::new();

        // include the log from the OxideInstance RoT in the digest
        for log in &logs {
            match log.rot {
                RotType::OxideInstance => data_digest.update(&log.data),
                _ => continue,
            }
        }

        // update digest w/ data provided by the VM
        data_digest.update(&nonce);
        data_digest.update(&USER_DATA);

        // smuggle this data into the `verify_attestation` function in the
        // `attest_data::Nonce` type
        let data_digest = data_digest.finalize();
        let data_digest = attest_data::Nonce {
            0: data_digest.into(),
        };

        // get the log from the Oxide platform RoT
        let oxlog = logs.iter().find_map(|log| {
            if log.rot == RotType::OxidePlatform {
                Some(log)
            } else {
                None
            }
        });

        // put log in the form expected by the `verify_attestation` function
        let (log, _): (Log, _) = if let Some(oxlog) = oxlog {
            hubpack::deserialize(&oxlog.data)
                .expect("deserialize hubpacked log")
        } else {
            panic!("No measurement log for RotType::OxidePlatform");
        };

        let result = dice_verifier::verify_attestation(
            &cert,
            &attestation,
            &log,
            &data_digest,
        );
        assert!(result.is_ok());
    }

    #[test]
    fn appraise_log() {
        use dice_verifier::{MeasurementSet, ReferenceMeasurements};
        use rats_corim::Corim;

        let attest = setup();

        let corim = Corim::from_file(config::CORIM).expect("Corim from file");
        let rims =
            ReferenceMeasurements::try_from(std::slice::from_ref(&corim))
                .expect("Reference integrity measurements from file");

        // get cert chain required to reconstruct the collection of measurements
        let cert_chains = attest
            .get_cert_chains()
            .expect("VmInstanceAttestMock get_cert_chain");
        let cert_chain = cert_chains.iter().find_map(|cert_chain| {
            if cert_chain.rot == RotType::OxidePlatform {
                Some(cert_chain)
            } else {
                None
            }
        });
        let cert_chain = if let Some(cert_chain) = cert_chain {
            cert_chain
        } else {
            panic!("No cert chain for RotType::OxidePlatform");
        };

        // construct a `VmInstanceConf` from test data
        // this is our reference for appraising the log produced by the
        // `RotType::OxideInstance`
        let instance_rim = fs::read_to_string(config::VM_INSTANCE_CFG)
            .expect("read ATTEST_INSTANCE_LOG to string");
        let instance_rim: VmInstanceConf = serde_json::from_str(&instance_rim)
            .expect("parse JSON from rim for instance RoT log");

        let logs = attest.get_measurement_logs().expect("get_measurement_logs");
        for log in &logs {
            match log.rot {
                RotType::OxidePlatform => {
                    // use dice-verifier crate to use the RIMs to appraise the
                    // log from the OxidePlatform RoT
                    let (log, _): (Log, _) = hubpack::deserialize(&log.data)
                        .expect("deserialize hubpacked log");
                    let mut cert_chain_pem = Vec::new();
                    for cert in &cert_chain.certs {
                        cert_chain_pem.push(
                            Certificate::from_der(&cert)
                                .expect("Certificate from DER"),
                        );
                    }

                    let measurements =
                        MeasurementSet::from_artifacts(&cert_chain_pem, &log)
                            .expect("MeasurementSet from PkiPath and Log");

                    let result = dice_verifier::verify_measurements(
                        &measurements,
                        &rims,
                    );
                    assert!(result.is_ok());
                }
                RotType::OxideInstance => {
                    // compare log / config description from the OxideInstance
                    // RoT to the reference from the config reference
                    let instance_cfg = std::str::from_utf8(&log.data)
                        .expect("utf8 from log data");
                    let instance_cfg: VmInstanceConf =
                        serde_json::from_str(instance_cfg)
                            .expect("parse JSON from log data");

                    assert_eq!(instance_rim, instance_cfg);
                }
            }
        }
    }
}
